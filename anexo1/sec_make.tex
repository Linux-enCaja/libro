\section{Makefile}
%Para qué se usa ....
%Implicaciones en el desarrollo de este libro
%El problema que los proyectos son muy extensos en código y reconstruir todo es tedioso y repititivo....
s
El desarrollo de aplicaciones a partir de herramientas libres se apoya en la herramienta de construcción \textit{make}, la cual automatiza la creación los archivos binarios de una aplicación. La herramienta construcción \textit{make} comunmente llamada constructor, utiliza el archivo \textbf{Makefile} para tomar la especificación del proyecto a construir. Con base en el \textit{Makefile} se ejecutan las reglas necesarias para construir el proyecto. En general el objetivo final del \textit{make} es construir una aplicación, pero dada la flexibilidad que tiene se utiliza para construir cualquier tipo de proyecto que requiera muchas etapas de compilación.

\subsection{Target, prerequisitos y reglas asociadas}

El constructor a través de las reglas descritas en el archivo \textit{Makefile} determina cual y cuando se debe reconstruir un archivo para completar la construcción del proyecto completo; todo esto se realiza  en base a las marcas de tiempo de los archivos fuentes y el de salida (\textit{target}). Sí los archivos fuentes que son prerequisitos de una regla tiene una marca de tiempo más reciente, el constructor determina que este archivo se debe reconstruir.\\

Las reglas del constructor se componen de un \textit{target} o archivo de salida (generalmente un archivo de salida por regla) y una serie de pre-requisitos para cada regla. Los pre-requisitos de cada regla se deben encontrar en las rutas de búsqueda del constructor para completar la construcción del proyecto; sí algún pre-rerquisito no existe el construcctor buscará una regla asociada para su construción. Dado el caso que no exista algún archivo pre-requisito ni una regla asociada a este, el constructor falla con un mensaje de error de falta de pre-requisitos. A continuación se muestra un ejemplo de la sintaxis de una regla para compilar \textit{foo.c} en \textit{foo.o}

\begin{lstlisting}
target1.o:	source1.c header1.h
			gcc -c source1.c
\end{lstlisting}

En las reglas del constructor, el nombre del archivo ubicado antes de los dos puntos (\textbf{:}) se le denomina \textit{target} en este caso \textit{target1.o}\textbf{:}. La lista de archivos que suceden a los dos puntos (\textbf{:}) se le llama la lista de prerequisitos.

Los pre-requisitos son los archivos que el \textit{target} necesita para su construcción, en este caso \textit{source1.c} y \textit{header1.h}. El tipo de archivo del \textit{target} y de los prerequisitos no tiene importancia dado que únicamente se verifica su existencía y marca de tiempo. La línea que sigue al \textit{target} se le conoce como la primer linea de ejecución de la regla o \textit{recipe}. Es necesario identar con un carácter de tabulación ($\rightarrow$) las lineas de comandos para que el constructor las ejecute correctamente. La ejecución del \textit{recipe} se realiza en una consola diferente a la en que se invoca el comando \textit{make}. Cuando se tienen lineas muy extensas se puede usar el carácter \textit{backslash} \textbf{\\}

\subsubsection{Tipos de reglas del constructor}

Existen diferentes tipos de reglas que el constructor puede tomar como referencia para ejecutar comandos externos. Estas reglas pueden ser reglas explícitas, reglas basadas en comodines, reglas imperativas o reglas vacías.

\paragraph{Reglas explicitas:} Las reglas explícitas son las que constructor toma cuando un \textit{target} no se encuentra actualizado. El anterior ejemplo muestra como una regla explicita asociada al \textit{target1.o}. En algunas ocaciones dos o más \textit{targets} tienen los mismos prerequisitos para estos casos se pueden definir todos los \textit{targets} en una lista y asociarlos a una sola regla:

\begin{lstlisting}
target1.o target2.o:	source1.c header1.h
\end{lstlisting}

\paragraph{Reglas basadas en comodines \textit{Wildcards}:}

Cuando los proyectos contienen una gran cantidad de objetos por construir la cración de un \textit{Makefile} puede tornarse en una tarea repititiva y tomar un tiempo considerable. Para evitar esto el constructor tiene la herramienta de comodines (\textit{wildcards}), los comodines permiten agilizar la creación de un \textit{Makefile} mediante la reducción de la cantidad de códigos que deban construir. Dada la relación estrecha entre el constructor y el \textit{shell} los comodines allí utilizados son heredados por el constructor, los comodines más utilizados son:
\begin{itemize}
	\item \textbf{\~}	:   Este símbolo se usa para representar la ruta de la carpeta \textit{home} del usuario que ejecuta el constructor.
	\item \textbf{*}	:   El asterísco es usado para reemplazar una cadena de caracteres completa por ejemplo: Los siguientes archivos \textit{target1.o}, \textit{target2.o} y \textit{target3.o} se pueden representar como \textit{*.o}
	\item \textbf{?}	:   El funcionamiento de este carácter es similar al \textbf{\*} pero en este caso no se remplaza una cadena completa sino un solo carácter.
\end{itemize}

\paragraph{Reglas de ejecución imperativa (.\textit{PHONY}):}

Generalmente las reglas incluidas en los \textit{Makefile} son reglas de tipo explicitas, como ya se mencionó estas reglas revisan la relación entre el  \textit{target} y sus prerequisitos. Si se requiere que una regla se ejecute sin tomar en cuenta ninguna relación de los prerequisitos y el \textit{target} se puede usar las reglas de tipo imperativa (.\textit{PHONY}). Un ejemplo claro de cuando se requiere utilizar las reglas imperativas en el caso de tener el siguiente \textit{Makefile}. Este archivo  tiene la regla \textit{clean} la cual no tiene prerequisitos y ejecuta el comando \textbf{rm -f *.o} para eleminar todos los archivos con extensión \textit{o}. La ejecución de esta regla se puede realizar mediante  \textbf{\$ make clean}. 

\begin{lstlisting}
clean:
		rm -f *.o
\end{lstlisting}

La anterior regla se ejecuta sin ningún inconveniente cuando no existe un archivo llamado \textit{clean} dentro de las rutas de búsqueda del cosntructor, dado que no tiene ningún pre-requisito esta regla siempre se ejecuta al ser invocada. Pero si en la ruta del constructor existe un archivo de nombre \textit{clean} el constructor determina que el \textit{target} de dicha regla se encuentra al día y no se debe ejecutar sus comandos de construcción terminando su ejecución con la siguiente salida:

\begin{lstlisting}
$ make clean
make: 'clean' is upt to date.
$
\end{lstlisting}

Para prevenir este comportamiento indeseado se puede declarar la regla de la siguiente manera:

\begin{lstlisting}
.PHONY: clean
clean:
		rm -f *.o
\end{lstlisting}

La regla \textit{.PHONY} fuerza la ejecución de esta regla independientemente si el \textit{target} está al día, todos los comandos de la regla se ejecutan cuando es invocada o es pre-requisito de otra regla en ejecución.

Por otra parte existen reglas tipo \textit{PHONY} prestablecidas o estándares, estas reglas son definidas directamente por el constructor. Cada una de ellas se muestran en la siguiente tabla:


\begin{table}
\caption{Reglas imperativas comunes}
	\begin{tabular}{p{0.3\textwidth}p{0.7\textwidth}}
	
	\hline
	\textit{Target} & Función (\textit{\$}) \\
	\hline
	
	\textbf{all} 		& 	Realiza todas las tareas necesarias para construir el proyecto \\
	\textbf{install} 	&	Instala la aplicación tomando los binaros compilados \\
	\textbf{clean} 		&	Borra los binarios de la aplicación y los archivos generados en su construcción \\
	\textbf{distclean} 	&	Borra todos los archivos generados que no hacen parte del codigo fuente de la distribución \\
	
	
	\end{tabular}
\end{table}

\subsubsection{Reglas vaciás}

Las reglas vacias son una variante directa de las reglas imperativas; estas reglas generalmente se usan para guardar un evento de construcción. La forma en que se puede guardar un evento de construcción es mediante la ejecución del comando \textbf{touch} sobre el \textit{target}. 

\begin{lstlisting}
plot: source1.c header1.h
		touch plot
\end{lstlisting}

\subsection{Variables}

Las variables del constructor se utilizan para representar cadenas de caracteres, que pueden hacer referencia a nombres de archivos, directorios, opciones del compilador, programas a ejcutar en la construcción de la aplicación, en general puede representar virutalmente cualquier cosa. Para definir una variable se debe ubicar el nombre de la variable en una nueva linea seguido del símbolo \textbf{=} y por último el valor que se desa contener. Para expandir la variable o usar su contenido se usa la misma sintaxis del \textit{bash} \$(\textit{(nombre-variable)})\\

El nombre de una variable no puede contener los carateres especiales \textbf{:}, \textbf{\#}, \textbf{\=} o espacios en blanco, por otra parte los nombres de las variables al igual que la variables del \textit{bash} son sensibles a mayusculas y minusculas. Se recomienda el uso de mayusculas sostenidas para las variables que sean parámetros de conficuración, rutas del sistema y minusculas para el nombre de archivos de salida, programas que se deban ejecutar. 

\subsubsection{Variables automáticas}

Las variables automáticas permiten acceder a nombres preestablecidos de los componentes de una regla, como el \textit{target}, los prerequisitos. A continuación se listan las variables automáticas más frecuentes:

\begin{table}
\caption{Variables automáticas}
	\begin{tabular}{p{0.1\textwidth}p{0.9\textwidth}}
	\hline
	\textit{Variable} & Función  \\
	\hline

	\textbf{@} 		& Denota el nombre del \textit{target} de la regla.\\
	\textbf{\%}		& Denota el nombre del archivo dentro de una lista.\\
	\textbf{<}		& Es el nombre del primer prerequisito de la regla.\\
	\textbf{?}		& El nombre de todos los prerequisitos de la regla y que tienen una marca de tiempo mayor al \textit{target} en una lista separada poro espacios\\
	\textbf{\^}		& Es la lista de todos los prerequisitos de la regla separada por espacios. Los nombres repetidos son automáticamente eliminados para evitar ejecuciones reentrantes en el construcctor.\\
	\textbf{+}		& Es la lista de todos los prerequisitos de la regla separados por espacios, esta lista incluye nombres repetidos. \\
	\textbf{*}		& Es el nombre del archivo de salida sin su extensión de salida.
	\end{tabular}
\end{table}

La variables automáticas del constructor tambien se deben expandir al llamase es decir, al constructor se le debe decir que el caracter que se está escribiendo es una variable, para eso se debe anteponer el caracter \textbf{\$} antes de cada variable automática.

%\subsubsection{Variables automáticas de rutas de archivos (VPATH y vpath)}

%Cuando se tienen proyectos con gran cantidad de archivos usualmente los desarrolladores crean una estructura de carpetas organizando de esta manera el código.


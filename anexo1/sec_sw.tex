
\section{Herramientas compilación y desarrollo de proyectos SW}%%%Esto está feo.... Nombre más específico

%!Esto necesita sustento en un libro falta incluir referencias de esta sección

%!Esto es solo una idea de introducción a la sección falta cambiar
Para el desarrollo de aplicaciones \textit{software} mediante lenguales de alto nivel permíten acelerar el desarrollo de la aplicación, pero requiere de un conjunto de herramientas para la creación del archivo final. Estas herramientas llevan el conjunto de archivos fuentes y paso a paso los convierten en un archivo ejecutable por la máquina, llamado binario. 

%!Esta figura toca hacerla conteniendo las dos y explicarlas en el texto de abajo
\begin{figure}[h]
  \begin{center} \includegraphics[scale=.5]{./anexo1/images/toolchain_reducido} \end{center}
  \caption{Flujo de diseño SW utilizando la cadena de herramientas GNU}\label{toolchain_flow}
\end{figure}

\section{Flujo de diseño software}
%R Real-Time Concepts for Embedded Systems
En la figura \ref{toolchain_flow} se ilustra la secuencia de pasos que se realizan desde la creación de un archivo de texto que posee el código fuente de una aplicación hasta su implementación en la tarjeta de desarrollo. Los pasos necesarios para generar un ejecutable para un sistema embebido son:

\begin{figure}[h]
  \begin{center} \includegraphics[scale=.6]{./anexo1/images/SW_design_flow} \end{center}
  \caption{Flujo de diseño SW utilizando la cadena de herramientas GNU}\label{toolchain_flow}
\end{figure}

\begin{enumerate}
 \item \textbf{Escritura del código fuente:} Los entornos de desarrollo \textit{software} IDE (\textit{integrated development environment}) proveen de un editor de texto y la colección de herramientas están integradas en la misma aplicación, para el caso de desarrollo de aplicaciones con \textit{software} libre existen alternativas como \url{www.eclipse.com} para la integración de herramientas, pero no es un requisito para escribir códigos fuentes el uso de un editor en particualar, cada programador puede escribir sus códigos en la interfaz que le resulte más amigable. Los codigos fuentes de los programas para sistemas embebidos generalmente son escritos en C/C++. Algunas partes específicas son escritas en lenguaje ensamblador por motivos de eficiencia en tiempo de ejecución o tamaño. 

 \item \textbf{Compilación:} Los archivos fuentes C y los archivos de ensamblador (generamente s) son tomados por las herramientas de compilación para crear archivos tipo objetos. Estos objetos contienen las instrucciones que el procesador deberá ejecutar cuando las funciones sean invocadas para cumplir con la funcionalidad deseada. Además, estos archivos contienen la información de las etiquetas usadas en el proceso de enlazado e información sobre la compilación misma. Por último, los objetos no contienen las direcciones específicas de donde se implementa una función, por ejemplo, el compilador busca en los encabezados (\textit{headers} .h) de la función \textit{printf} en la librerira \textit{stdio.h}, pero no busca el segmento de código donde está implementada.
%!!!Aquí voy JRB-- Adecuando cosas!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 \item \textbf{Enlazado:} En esta etapa se realizan dos tareas: 
  \begin{enumerate} 
    \item Se enlazan los archivos tipo objeto del proyecto junto con las librerías, si una determinada función no es definida por ninguna de las librerías pasadas como parámetro al enlazador (\textit{linker}), este generará un error y no se generará el ejecutable.
    \item Se definen la posiciones físicas de las secciones del ejecutable (tipo ELF), esto se realiza a través de un \textit{script de enlazado} que define de forma explícita su localización.
  \end{enumerate}

 \item \textbf{Extracción del archivo de programación} En algunas aplicaciones es necesario extraer únicamente las secciones que residen en los medios de almacenamiento no volátil y eliminar las demás secciones del ejecutable. Esto se realiza con la herramienta \textit{objcopy}, la cual, permite generar archivos en la mayoría de los formatos soportados por los programadores de memorias y procesadores, como por ejemplo S19 e Intel Hex. Adicionalmente se puede generar un archivo binario que contiene las instrucciones en lenguaje del procesador, y pueden ser descargadas directamente a la memoria de la plataforma.

 \item \textbf{Descarga del programa}. Dependiendo de la plataforma, existen varios métodos para descargar el archivo de programación:
  \begin{enumerate}
    \item Utilizando un \textit{loader}: El \textit{loader} es una aplicación que reside en un medio de almacenamiento no volátil y permite la descarga de archivos utilizando el puerto serie o una interfaz de red a una memoria no volátil externa.
    \item Utilizando el puerto JTAG: El puerto JTAG (Joint Test Action Group) proporciona una interfaz capaz de controlar los registros internos del procesador, y de esta forma, acceder a las memorias de la plataforma y ejecutar un programa residente en una posición de memoria determinada.
  \end{enumerate}
%! Recordar que hay una etapa donde se dedica completamente a las interfases de programación
 \item \textbf{Depuración} Una vez se descarga la aplicación a la plataforma es necesario someterla a una serie de pruebas, para verificar su correcto funcionamiento. Esto se puede realizar con el depurador GNU (GDB) y una interfaz de comunicación que puede ser un puerto serie, USB o un adaptador de red.
 
\end{enumerate}

\subsubsection{GNU binutils}
Todas las aplicaciones mencionadas a continuación hacen parte de la cadena de herramientas GNU, que son parte de los recursos suministrados por la comunidad de software libre.
Colección de utilidades para archivos binarios y están compuestas por:

\begin{itemize}
 \item  \textbf{addr2line} Convierte direcciones de un programa en nombres de archivos y números de línea. Dada una dirección y un ejecutable, usa la información de depuración en el ejecutable para determinar que nombre de archivo y número de línea está asociado con la dirección dada.
 \item  \textbf{ar} Esta utilidad crea, modifica y extrae desde ficheros; un fichero es una colección de otros archivos en una estructura que hace posible obtener los archivos individuales. 
 \item  \textbf{as} Utilidad que compila la salida del compilador de C (GCC).
 \item  \textbf{c++filt} Este programa realiza un mapeo inverso: Decodifica nombres de bajo-nivel en nombres a nivel de usuario, de tal forma que el \textit{linker} pueda mantener estas funciones sobrecargadas (overloaded) ``from clashing''. 
 \item  \textbf{gasp} GNU Assembler Macro Preprocessor
 \item  \textbf{ld} El \textit{linker} GNU combina un número de objetos y ficheros, re-localiza sus datos y los relaciona con referencias. Normalmente el último paso en la construcción de un nuevo programa es el llamado a ld.
 \item  \textbf{nm} Realiza un listado de símbolos de archivos tipo objeto.
 \item  \textbf{objcopy} Copia los contenidos de un archivo tipo objeto a otro. \textit{objcopy} utiliza la librería GNU BFD para leer y escribir el archivo tipo objeto. Permite escribir el archivo destino en un formato diferente al del archivo fuente. 
 \item  \textbf{objdump} Despliega información sobre archivos tipo objeto. 
 \item  \textbf{ranlib} Genera un índice de contenidos de un fichero, y lo almacena en él.
 \item  \textbf{readelf} Interpreta encabezados de un archivo ELF.
 \item  \textbf{size} Lista el tamaño de las secciones y el tamaño total de un archivo tipo objeto.
 \item  \textbf{strings} Imprime las secuencias de caracteres imprimibles de al menos 4 caracteres de longitud. 
 \item  \textbf{strip} Elimina todos los símbolos de un archivo tipo objeto.
\end{itemize}

\subsubsection{Compilador}
El \textit{GNU Compiler Collection} normalmente llamado GCC, es un grupo de compiladores de lenguajes de programación producido por el proyecto GNU. Es el compilador estándar para el software libre, de los sistemas operativos basados en Unix y algunos propietarios como Mac OS de Apple. Soporta los lenguajes ADA, C, C++, Fortran, Java, Objective-C, Objective-C++ para las arquitecturas Alpha, ARM, Atmel AVR, Blackfin, H8/300, System/370, System/390, IA-32 (x86), x86-64, IA-64 i.e. the "Itanium", Motorola 68000, Motorola 88000, MIPS, PA-RISC, PDP-11, PowerPC, SuperH, SPARC, VAX, Renesas R8C/M16C/M32C y MorphoSys. Gracias a esto puede considerarse como una herramienta universal para el desarrollo de sistemas embebidos, el código escrito en una plataforma (en un lenguaje de alto nivel) puede ser implementado en otra sin mayores cambios, esto elimina la dependencia entre el código fuente y el procesador (re-utilización de código), lo que no es posible cuando se utiliza el lenguaje ensamblador. 

\subsubsection{GNU Debugger}
El depurador oficial de GNU (GDB) al igual que GCC, soporta múltiples lenguajes y plataformas; permite monitorear y modificar las variables internas del programa y hacer llamado a funciones de forma independiente a la ejecución normal del mismo. Además, permite establecer sesiones remotas utilizando el puerto serie o TCP/IP. Aunque GDB es una aplicación que se ejecuta en consola de comandos, se han desarrollado varios front-ends como DDD o GDB/Insight.

\subsubsection{Librerías C}
Es necesario contar con las librerías standard de C: stdio, stdlib, math, etc; las más utilizadas en sistemas embebidos son:

\begin{itemize}
 \item \textbf{glibc} Es la librería C oficial del proyecto GNU; el principal inconveniente al trabajar con esta librería en sistemas embebidos es que genera ejecutables de mayor tamaño que los generados a partir de otras librerías, lo cual no la hace muy atractiva para este tipo de aplicaciones. 
 \item \textbf{uClibc} Es una librería diseñada especialmente para sistemas embebidos, es mucho más pequeña que \textbf{glibc}.
 \item \textbf{newlib} Al igual que \textbf{uClibc}, está diseñada para sistemas embebidos. El típico ``Hello, world!'' ocupa menos de 30k en un entorno basado en newlib, mientras que en uno basado en glibc, puede ocupar 380k. 
 \item \textbf{diet libc} Es una versión de \textit{libc} optimizada en tamaño, puede ser utilizada para crear ejecutables estáticamente enlazados para Linux en plataformas alpha, arm, hppa, ia64, i386, mips, s390, sparc, sparc64, ppc y x86\_64.
\end{itemize}

\subsection{El formato ELF}

\subsubsection{El formato \textbf{ELF}}

El formato ELF (\textit{Executable and Linkable Format}) Es un estándar para objetos, librerías y ejecutables y es el formato que generan las herramientas GNU. Como puede verse en la figura \ref{elf1} un ejecutable \textit{ELF} está compuesto por las secciones (\textit{link view}) o segmentos (\textit{execution view}). Si un programador está interesado en obtener información de secciones sobre tablas de símbolos, código ejecutable específico o información de enlazado dinámico debe utilizar \textit{link view}. Pero si busca información sobre segmentos, como por ejemplo, la localización de los segmentos \textit{text} o \textit{data} debe utilizar \textit{execution view}. El encabezado describe el layout del archivo, proporcionando información de la forma de acceder a las secciones \cite{MLH98}.
%! Esta imagen me toca cambiarla vectorizarla o hacer una tabla!
\begin{figure}[h]
  \begin{center} \includegraphics[scale=.4]{./anexo1/images/ELF_Link_exec1} \end{center}
  \caption{Formato ELF}\label{elf1}
\end{figure}

Las secciones pueden almacenar código ejecutable, datos, información de enlazado dinámico, datos de depuración, tablas de símbolos,comentarios, tablas de cadenas, y notas. Las secciones más importantes son:

\begin{itemize}
 \item \textbf{.bss}            Datos no inicializados. (RAM)
 \item \textbf{.comment}        Información de la versión.
 \item \textbf{.data y .data1}  Datos inicializados.    (RAM)
 \item \textbf{.debug}          Información para depuración simbólica. 
 \item \textbf{.dynamic}        Información sobre enlace dinámico 
 \item \textbf{.dynstr}         Strings necesarios para el enlace dinámico 
 \item \textbf{.dynsym}         Tabla de símbolos utilizada para enlace dinámico.
 \item \textbf{.fini}           Código de terminación de proceso.
 \item \textbf{.init}           Código de inicialización de proceso.
 \item \textbf{.line}           Información de número de línea para depuración simbólica.
 \item \textbf{.rodata y .rodta1} Datos de solo-lectura (ROM)
 \item \textbf{.shstrtab}       Nombres de secciones.
 \item \textbf{.symtab}         Tabla de símbolos.
 \item \textbf{.text}           Instrucciones ejecutables (ROM)
\end{itemize}

%Falta explicar los ELF dinamicos usados en linux y un ejemplo de como la memoria virtual usa estos archivos

%% Ejemplo de aplicación
Para aclarar el contenido de cada una de estas secciones, consideremos la siguiente aplicación sencilla:

\begin{lstlisting}
#include <stdio.h>

int global;
int global_1 = 1;

int main(void)
{
  int i;                                // Variable no inicializada
  int j = 2;                            // Variable inicializada
  for(i=0; i<10; i++){
    printf("Printing %d\n", i*j);       // Caracteres constantes
    j = j + 1;
    global   = i;
    global_1 = i+j;
  }
  return 0;
}
\end{lstlisting}

Generemos el objeto compilándolo con el siguiente comando:
\textit{arm-none-linux-gnueabi-gcc -c hello.c}

Examinemos que tipo de secciones tiene este ejecutable
\textit{arm-none-linux-gnueabi-readelf -S hello.o}

\begin{lstlisting}[style=numbered]
Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00000000 000034 00009c 00  AX  0   0  4
  [ 2] .rel.text         REL             00000000 000484 000020 08      9   1  4
  [ 3] .data             PROGBITS        00000000 0000d0 000004 00  WA  0   0  4
  [ 4] .bss              NOBITS          00000000 0000d4 000000 00  WA  0   0  1
  [ 5] .rodata           PROGBITS        00000000 0000d4 000010 00   A  0   0  4
  [ 6] .comment          PROGBITS        00000000 0000e4 00004d 00      0   0  1
  [ 7] .ARM.attributes   ARM_ATTRIBUTES  00000000 000131 00002e 00      0   0  1
  [ 8] .shstrtab         STRTAB          00000000 00015f 000051 00      0   0  1
  [ 9] .symtab           SYMTAB          00000000 000368 0000f0 10     10  11  4
  [10] .strtab           STRTAB          00000000 000458 00002b 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
\end{lstlisting}

La sección \textit{.text}, como se dijo anteriormente contiene las instrucciones ejecutables, por esta razón se marca como ejecutable \textit{``X''} en la columna \textit{Flg}. Es posible ver las instrucciones que se ejecutan en esta sección ejecutando:

\textit{arm-none-linux-gnueabi-objdump -d -j .text hello.o}

\begin{lstlisting}[style=numbered]
00000000 <main>:
   0:   e92d4800        stmdb   sp!, {fp, lr}
   4:   e28db004        add     fp, sp, #4      ; 0x4
   8:   e24dd008        sub     sp, sp, #8      ; 0x8
   c:   e3a03002        mov     r3, #2  ; 0x2
  10:   e50b3008        str     r3, [fp, #-8]
  14:   e3a03000        mov     r3, #0  ; 0x0
  18:   e50b300c        str     r3, [fp, #-12]
  1c:   ea000013        b       70 <main+0x70>
  20:   e51b200c        ldr     r2, [fp, #-12]
  24:   e51b3008        ldr     r3, [fp, #-8]
  28:   e0030392        mul     r3, r2, r3
  2c:   e59f005c        ldr     r0, [pc, #92]   ; 90 <.text+0x90>
  30:   e1a01003        mov     r1, r3
  34:   ebfffffe        bl      0 <printf>
  38:   e51b3008        ldr     r3, [fp, #-8]
  3c:   e2833001        add     r3, r3, #1      ; 0x1
  40:   e50b3008        str     r3, [fp, #-8]
  44:   e59f2048        ldr     r2, [pc, #72]   ; 94 <.text+0x94>
  48:   e51b300c        ldr     r3, [fp, #-12]
  4c:   e5823000        str     r3, [r2]
  50:   e51b200c        ldr     r2, [fp, #-12]
  54:   e51b3008        ldr     r3, [fp, #-8]
  58:   e0822003        add     r2, r2, r3
  5c:   e59f3034        ldr     r3, [pc, #52]   ; 98 <.text+0x98>
  60:   e5832000        str     r2, [r3]
  64:   e51b300c        ldr     r3, [fp, #-12]
  68:   e2833001        add     r3, r3, #1      ; 0x1
  6c:   e50b300c        str     r3, [fp, #-12]
  70:   e51b300c        ldr     r3, [fp, #-12]
  74:   e3530009        cmp     r3, #9  ; 0x9
  78:   daffffe8        ble     20 <main+0x20>
  7c:   e3a03000        mov     r3, #0  ; 0x0
  80:   e1a00003        mov     r0, r3
  84:   e24bd004        sub     sp, fp, #4      ; 0x4
  88:   e8bd4800        ldmia   sp!, {fp, lr}
  8c:   e12fff1e        bx      lr
\end{lstlisting}

La sección \textit{.data} mantiene las variables inicializadas, y contiene:
 
\textit{arm-none-linux-gnueabi-objdump -d -j .data hello.o}
 
\begin{lstlisting}[style=numbered]
00000000 <global_1>:
   0:   01 00 00 00
\end{lstlisting}

Como vemos, la sección \textit{.data} contiene únicamente el valor de inicialización de la variable \textit{global\_1} (1) y no muestra información acerca de la variable \textit{j}, esto se debe a que la información está en el \textit{stack} del proceso. Si observamos el contenido de la sección \textit{.text} observamos que esta variable es asignada en tiempo de ejecución, en la línea \textit{0c:} se ve la asignación de esta variable:

\begin{lstlisting}[style=numbered]
0c:   e3a03002        mov     r3, #2  ; 0x2 
10:   e50b3008        str     r3, [fp, #-8]
\end{lstlisting}

La sección \textit{.bss} mantiene la información de las variables no inicializadas. En Linux todas las variables no inicializadas, se inicializaran en cero:

\textit{arm-none-linux-gnueabi-objdump -d -j .bss hello}
 
\begin{lstlisting}[style=numbered]
000145c4 <global>:
    145c4:       00000000
\end{lstlisting}
   
La sección \textit{.rodata} contiene los datos que no cambian durante la ejecución del programa, es decir, los de solo lectura, si examinamos esta sección obtenemos:
 
\textit{hexdump -C hello.o | grep -i 000000d0} (la sección \textit{.rodata} comienza en la posición de memoria 0xd4)
 
  
\begin{lstlisting}[style=numbered]
000000d0  01 00 00 00 50 72 69 6e  74 69 6e 67 20 25 64 0a  |....Printing %d.|
000000e0  00 00 00 00 00 47 43 43  3a 20 28 43 6f 64 65 53  |.....GCC: (CodeS|
\end{lstlisting}
 
Observamos que en el archivo se almacena la cadena de caracteres \textit{Printing \%d\\n} la cual no se modifica durante la ejecución del programa.
\subsection{Script del enlazador \textit{Linker}}
\subsubsection{Linker Script}
Como vimos anteriormente, el \textit{linker} es el encargado de agrupar todos los archivos objeto \textit{.o}, y las librerías necesarias para crear el ejecutable, este \textit{linker} permite definir donde serán ubicados los diferentes segmentos del archivo ELF, por medio de un archivo de enlace \textit{linker script}. De esta forma podemos ajustar el ejecutable a plataformas con diferentes configuraciones de memoria. Esto brinda un grado mayor de flexibilidad de la cadena de herramientas GNU. Cuando se dispone de un sistema operativo como Linux no es necesario definir este archivo para los ejecutables, ya que el sistema operativo se encarga de guardar las secciones en el lugar indicado; sin embargo, es necesario tenerlo presente ya que como veremos más adelante existe un momento en el que el sistema operativo no ha sido cargado en la plataforma y las aplicaciones que se ejecuten deben proporcionar esta información. A continuación se muestra un ejemplo de este archivo:

\lstset{emph={flash}, emphstyle=\color{red}, emph={[2]ram,base},emphstyle={[2]\color{blue}}}

\begin{lstlisting}
 /* identify the Entry Point  (_vec_reset is defined in file crt.s)  */
ENTRY(_vec_reset)

/* specify the memory areas  */
MEMORY 
{
    flash : ORIGIN = 0,          LENGTH = 256K    /* FLASH EPROM          */
    ram   : ORIGIN = 0x00200000, LENGTH = 64K     /* static RAM area      */
}

/* define a global symbol _stack_end */
_stack_end = 0x20FFFC;

/* now define the output sections  */
SECTIONS
{
  . = 0;            /* set location counter to address zero  */
  .text :           /* collect all sections that should go into FLASH after startup  */
  {
    *(.text)        /* all .text sections (code)  */
    *(.rodata)      /* all .rodata sections (constants, strings, etc.)  */
    *(.rodata*)     /* all .rodata* sections (constants, strings, etc.)  */
    *(.glue_7)      /* all .glue_7 sections  (no idea what these are) */
    *(.glue_7t)     /* all .glue_7t sections (no idea what these are) */
    _etext = .;     /* define a global symbol _etext just after the last code byte */
  } >flash          /* put all the above into FLASH */

  .data :           /* collect all initialized .data sections that go into RAM  */ 
  {
    _data = .;      /* create a global symbol marking the start of the .data section  */
    *(.data)        /* all .data sections  */
    _edata = .;     /* define a global symbol marking the end of the .data section  */
  } >ram AT >flash  /* put all the above into RAM (but load the LMA initializer copy 
                       into FLASH)  */

  .bss :            /* collect all uninitialized .bss sections that go into RAM  */
  {
    _bss_start = .; /* define a global symbol marking the start of the .bss section */
    *(.bss)         /* all .bss sections  */
  } >ram            /* put all the above in RAM (it will be cleared in the startup code*/
  . = ALIGN(4);     /* advance location counter to the next 32-bit boundary */
  _bss_end = . ;    /* define a global symbol marking the end of the .bss section */
}
_end = .;           /* define a global symbol marking the end of application RAM */
\end{lstlisting}

En las primeras líneas del archivo aparece la declaración de las memorias de la plataforma; en este ejemplo, tenemos una memoria RAM de 64kB que comienza en la posición de memoria 0x00200000 y una memoria flash de 256k que comienza en la posición 0x0. A continuación se definen las secciones y el lugar donde serán almacenadas; en este caso, las secciones \textit{.text} (código ejecutable) y \textit{.rodata} (datos de solo lectura) se almacenan en una memoria no volátil la flash. Cuando el sistema sea energizado el procesador ejecutará el código almacenado en su memoria no volátil. Las secciones \textit{.data} (variables inicializadas) y \textit{.bss} (variables no inicializadas) se almacenarán en la memoria volátil RAM, ya que el acceso a las memorias no volátiles son más lentas y tienen ciclos de lectura/escritura finitos.

En algunos SoCs no se dispone de una memoria no volátil, por lo que es necesario que la aplicación sea cargada por completo en la RAM. Algunos desarrolladores prefieren almacenar y ejecutar sus aplicaciones en las memorias volátiles durante la etapa de desarrollo, debido a que la programación de las memorias no volátiles toman mucho más tiempo. Obviamente una vez finalizada la etapa de desarrollo las aplicaciones deben ser almacenadas en memorias no volátiles.

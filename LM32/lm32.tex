\chapter{Implementación de tareas Software utilizando procesadores Soft Core}

\section{Introducción}

En el capítulo anterior se estudió la forma de implementar tareas hardware utilizando máquinas de estado algorítmicas. La implementación de tareas hardware es un proceso un poco tedioso ya que involucra la realización de una máquina de estados por cada tarea; la implementación del camino de datos se simplifica de forma considerable ya que existe un conjunto de bloques constructores que pueden ser tomados de una librería creada por el diseñador. El uso de tareas hardware se debe realizar únicamente cuando las restricciones temporales del diseño lo requieran, ya que como veremos en este capítulo, la implementación de tareas software es más sencilla y rápida.

La estructura de una máquina de estados algorítmica permite entender de forma fácil la estructura de un procesador ya que tienen los mismos componentes principales (unidad de control y camino de datos), la diferencia entre ellos es la posibilidad de programación y la configuración fija del camino de datos del procesador.

En este capítulo se estudiará la arquitectura del procesador MICO32 creado por la empresa Lattice semiconductor y gracias a que fué publicado bajo la licencia GNU, es posible su estudio, uso y modificación. En la primera sección se hace la presentación de la arquitectura; a continuación se realiza el análisis de la forma en que el procesador implementa las diferentes instrucciones, iniciando con las operaciones aritméticas y lógicas siguiendo con las de control de flujo de programa (saltos, llamado a función); después se analizarán la comunicación con la memoria de datos; y finalmente el manejo de interrupciones.

En la segunda sección se abordará la arquitectura de un SoC (System on a Chip) basado en el procesador LM32, se analizará la forma de conexión entre los periféricos y la CPU utilizando el bus wishbone; se realizará una descripción detallada de la programación de esta arquitectura utilizando herramientas GNU. 



%********************************************************************************************************************
%********************************************************                              SECCIÓN   ARQUITECTURA LM32
%********************************************************************************************************************
\section{Arquitectura del procesador LM32}


La figura \ref{lm32_arch_single} muestra el diagrama de bloques del soft-core LM32, este procesador utiliza 32 bits y una arquitectura de 6 etapas del pipeline; las 6 etapas del pipeline son:


\begin{enumerate}
 \item \textit{Address}: Se calcula la dirección de la instrucción a ser ejecutada y es enviada al registro de instrucciones.
 \item \textit{Fetch}: La instrucción se lee de la memoria.
 \item \textit{Decode}: Se decodifica la instrucción y se toman los operandos del banco de registros o tomados del bypass.
 \item \textit{Execute}: Se realiza la operacion especificada por la instrucción. Para instrucciones simples como las lógicas o suma, la ejecución finaliza en esta etapa, y el resultado se hace disponible para el bypass.
 \item \textit{Memory}: Para instrucciones más complejas como acceso a memoria externa, multiplicación, corrimiento, división, es necesaria otra etapa.
 \item \textit{Write back}: Los resultados producidos por la instrucción son escritas al banco de registros.
\end{enumerate}


\begin{figure}
  \begin{center} \includegraphics[scale=.6]{./LM32/images/lm32_block_diagram.pdf} \end{center}
  \caption{Diagrama de bloques del LM32}\label{lm32_arch_single}
\end{figure}

\subsection{Banco de Registros}
El LM32 posee 32 registros de 32 bits; el registro \textit{r0} siempre contiene el valor 0, esto es necesario para el correcto funcionamiento de los compiladores de C y ensamblador; los siguientes 8 registros (r1 a r7) son utilizados para paso de argumentos y retorno de resultados en llamados a funciones; si una función requiere más de 8 argumentos, se utiliza la pila (\textit{stack}). Los registros \textit{r1 - r28} pueden ser utilizados como fuente o destino de cualquier instrucción. El registro \textit{r29 (ra)} es utilizado por la instrucción \textit{call} para almacenar la dirección de retorno. El registro \textit{r30 (ea)} es utilizado para almacenar el valor del \textit{contador de programa} cuando se presenta una excepción. El registro \textit{r31 (ba)} almacena el valor del contador de programa cuando se presenta una excepción tipo \textit{breakpoint} o \textit{watchpoint}. Los registros \textit{r26 (gp)} \textit{r27 (fp)} y \textit{r28 (sp)} son el puntero global, de frame y de pila respectivamente.
 Después del reset el valor no se define el valor de los registros, por lo que la primera acción que debe ejecutar el programa de inicialización en colocar un cero en el registro \textit{r0 (\textbf{xor} r0, r0, r0)}



\subsection{Registro de estado y control}

La tabla \ref{csr} muestra los registros de estado y control (CSR), indicando si son de lectura o escritura y el índice que se utiliza para acceder al registro.

\begin{table}[htpb]
  \caption{Registro de Estado y Control}
  \centering
    \begin{tabular}{|l|l|l|}	
      \hline
      \textbf{Nombre}  & \textbf{Index} & \textbf{Descripción}  
      \\ \hline 
       IE          & 0x00 & (R/W)Interrupt enable        
      \\ \hline 
       EID         & ---- & (R)  Exception ID   
      \\ \hline 
       IM          & 0x01 & (R/W)Interrupt mask  
      \\ \hline 
       IP          & 0x02 & (R)  Interrupt pending 
      \\ \hline    
      ICC          & 0x03 & (W)  Instruction cache control   
      \\ \hline 
       DCC         & 0x04 & (W)  Data cache control  
      \\ \hline 
       CC          & 0x05 & (R)  Cycle counter 
      \\ \hline 
       CFG         & 0x06 & (R)  Configuration
      \\ \hline 
       EBA         & 0x07 & (R/W)Exception base address 
      \\ \hline 
    \end{tabular}
  \label{csr}
\end{table}

\subsubsection{Contador de Programa (PC)}
El contador de programa es un registro de 32 bits que contiene la dirección de la instrucción que se ejecuta actualmente. Debido a que todas las instrucciones son de 32 bits, los dos bits menos significativos del PC siempre son zero. El valor de este registro después del reset es \textit{h00000000}



\subsubsection{EID Exception ID}
El índice de la excepción es un número de 3 bits que indica la causa de la detención de la ejecución del programa. Las excepciones son eventos que ocurren al interior o al exterior del procesador y cambian el flujo normal de ejecución del programa. Los valores y eventos correspondientes son:



\begin{itemize}
 \item \textbf{0}: Reset; se presenta cuando se activa la señal de reset del procesador.
 \item \textbf{1}: Breakpoint; se presenta cuando se ejecuta la instrucción break o cuando se alcanza un punto de break hardware.
 \item \textbf{2}: Instruction Bus Error; se presenta cuando falla la captura e una instrucción, típicamente cuando la dirección no es válida.
 \item \textbf{3}: Watchpoint; se presenta cuando se activa un watchpoint.
 \item \textbf{4}: Data Bus Error; se presenta cuando falla el acceso a datos, típicamente porque la dirección solicitada es inválida o porque el tipo de acceso no es permitido.
 \item \textbf{5}: División por cero; Se presenta cuando se hace una división por cero.
 \item \textbf{6}: Interrupción; se presenta cuando un periférico solicita atención por parte del procesador, para que esta excepción se presente se deben habilitar las interrupciones globales (IE) y la interrupción del periférico (IM).
 \item \textbf{7}: System Call; se presenta cuando se ejecuta la instrucción \textit{scall}.
\end{itemize}

\subsubsection{IE Habilitación de interrupción}

l registro IE contiene el flag IE, que determina si se habilitan o no las interrupciones. Si este flag se desactiva, no se presentan interrupciones a pesar de la activación individual realizada con IM. Existen dos bits \textit{BIE} y \textit{EIE} que se utilizan para almacenar el estado de IE cuando se presenta una excepción tipo breakpoint u otro tipo de excepción; esto se explicará más adelante cuando se estudien las instrucciones relacionadas con las excepciones.


\subsubsection{IM Máscara de interrupción}
La máscara de interrupción contiene un bit de habilitación para cada una de las 32 interrupciones, el bit 0 corresponde a la interrupción 0. Para que la interrupción se presente es necesario que el bit correspondiente a la interrupción y el flag IE sean igual a 1. Después del reset el valor de IM es \textit{h00000000}


\subsubsection{IP Interrupción pendiente}

El registro IP contine un bit para cada una de las 32 interrupciones, este bit se activa cuando se presenta la interrupción asociada. Los bits del registro IP deben ser borrados escribiendo un 1 lógico.


- Compilación de progamas para el LM32, explicar un ejemplo sencillo puede ser el de tipos de datos comentandop todos los archivos, lm32, crt0.s, etc
- Set de instrucciones, con ejemplos en donde sea necesario como en:
   - llamado a funciones: Ejemplo sencillo que muestre como se pasan parámetros a través de r0, r1, r2.
   - saltos: If, while, forma
   - interrupciones explicar como se debe modificar el crt0.s para incluir los vectores de excepción y como se atiende la interrupción.
   - acceso a memoria externa: Explicar como se mapean los registros de los periféricos a C, y tipos de datos.
- Acceso a memoria externa: Bus wishbone: Topologías, señales del WB, arquitectura del conbus, explicar uart y timer.
- Como se forma el SoC con el LM32. Diagrama de bloques del SoC, explicando donde quedan los diferentes periféricos.





%********************************************************************************************************************
%********************************************************                              SECCIÓN   SET DE INSTRUCCIONES
%********************************************************************************************************************
\section{Set de Instrucciones del procesador Mico32}
En esta sección se realizará un análisis del conjunto de instrucciones del procesador Mico32; para facilitar el estudio se realizó una división en cuatro grupos comenzando con las instrucciones aritméticas y lógicas, siguiendo con las relacionadas con saltos, después se analizará la comunicación con la memoria de datos y finalmente las relacionadas con interrupciones y excepciones. Para cada uno de estos grupos se mostrará el camino de datos (simplificado) asociado al conjunto de instrucciones. 


\subsection{Instrucciones aritméticas}
En la figura \ref{arith_register} se muestra el camino de datos simplificado de las operaciones aritméticas y lógicas cuyos operandos son registros, y el resultado se almacena en un registro; en otras palabras son de la forma: \textbf{gpr[RX] = gpr[RY] {OP} gpr[RZ]}, donde: OP puede ser \textit{nor, xor, and, xnor, add, divu, modu, mul, or, sl, sr, sru, sub}. Como puede verse en esta figura la instrucción contiene la información necesaria para direccionar los registros que almacenan los operandos \textbf{RY} (instruction\_d 25:21) y \textbf{RZ} (instruction\_d 20:16), estas señales de 5 bits direccionan el banco de registros y el valor 
almacenado en ellos puede obtenerse en dos salidas diferentes ( \textbf{gpr[rz]} y \textbf{gpr[ry]}). En el archivo \textit{rtl/lm32/lm32\_cpu.v} se implementa el banco de registros de la siguiente forma:

\lstset{language=verilog}
\begin{lstlisting}
assign reg_data_0 = registers[read_idx_0_d];
assign reg_data_1 = registers[read_idx_1_d];
\end{lstlisting}


En este código \textit{reg\_data\_0} y \textit{reg\_data\_1} son las dos salidas \textbf{gpr[rz]} y \textbf{gpr[ry]}; las señales \textit{read\_idx\_0\_d} y \textit{read\_idx\_1\_d} corresponden a \textit{instruction\_d 25:21} y \textit{instruction\_d 20:16} respectivamente. El contenido de los registros direccionados de esta forma son llevados al modulo \textit{logic\_op} donde se realiza la operacion correspondiente a la instrucción y el resultado pasa a través de los estados del pipeline hasta llegar a la señal \textit{w\_result} (parte inferior de la figura) esta señal entra al banco de registros para ser almacenada en la dirección dada por la señal \textit{write\_idx\_w} la cual es fijada por la instrucción, más específicamente por \textit(instruction\_d 15:11). En el archivo \textit{rtl/lm32/lm32\_cpu.v} se implementa esta escritura al banco de registros de la siguiente forma: 

\lstset{language=verilog}
\begin{lstlisting}
always @(posedge clk_i)

begin

    if (reg_write_enable_q_w == `TRUE)

        registers[write_idx_w] <= w_result;

end
\end{lstlisting}


\subsubsection{Entre registros}
  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/arith_register.pdf} \end{center}
    \caption{Camino de datos de las operaciones aritméticas y lógicas entre registros}\label{arith_register}
  \end{figure}
  
 
 
 
\subsubsection{Inmediatas}

Existe otro grupo de operaciones lógicas y aritméticas en las que uno de los operandos es un registro y el otro es un número fijo, esto permite realizar operaciones con constantes que nos son almacenadas previamente en registros, sino que son almacenadas en la memoria de programa. En la figura \ref{arith_immediate} se muestra como se modifica el camino de datos para este tipo de instrucciones; en ella, podemos observar que \textit{instruction\_d 25:21} direcciona uno de los operandos que está almacenado en el banco de registros y de forma similar al caso anterior el dato almacenado es llevado al bloque \textit{logic\_op}. El segundo operando es llevado a este bloque desde un multiplexor donde se hace una extensión de signo de \textit{instruction\_d 15:0} o se hace un corrimiento a la derecha de 16 posiciones; esto, para convertir el número de 16 bits a uno de 32 bits, lo que da como resultado \textit{{16{instruction\_d[15]}}, instruction\_d[15:0]} y \textit{instruction\_d[15:0], 16'h0000} respectivamente; el 
corrimiento de 16 bits a la derecha se hace para poder realizar las operaciones \textit{andhi} y \textit{orhi}, las cuales solo operan sobre la parte alta de los operandos.

  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/arith_immediate.pdf} \end{center}
    \caption{Camino de datos de las operaciones aritméticas y lógicas inmediatas}\label{arith_immediate}
  \end{figure}

\subsection{Saltos}
Los saltos permiten controlar el flujo de ejecución del programa posibilitando la implementación de ciclos, llamado a funciones, y toma de decisiones. En esta subsección estudiaremos el camino de datos resultante para este tipo de instrucciones. A diferencia de las instrucciones aritméticas y lógicas, en este tipo de instrucciones se modifica el valor del contador de programa.

\subsubsection{Condicionales}

En la instrucción se almacena la dirección de los registros que deben ser comparados, específicamente en \textit{instruction\_d 25:21} y \textit{instruction\_d 20:16}; los valores almacenados en estos registros son llevados al sumador y a un bloque especial que determina si se cumple o nó la condición (señales rojas en la gráfica); la señal \textit{condition\_met\_x} se activa si la condición se cumple.

Para que el valor del contador de programa se modifique, es necesario que las señales \textit{condition\_met\_x}, \textit{branch\_m} y \textit{valid\_m} se encuentren activas (señales amarillas en la gráfica); la señal \textit{branch\_m} se activa cuando la instrucción es de tipo \textit{branch} o \textit{call}; la señal \textit{valid\_m} se activa cuando se presenta una instrucción válida. Adicionalmente, es necesario que el procesador no se encuentre en un estado de \textit{stall}. Si se cumplen las condiciones anteriores, se activará la señal \textit{branch\_taken\_m}, la que le indicará a la unidad de instrucciones que cargue el valor de la señal \textit{branch\_target\_m} en el contador de programa.

El valor de \textit{branch\_target\_m} (señal azul en la gráfica) es fijado por dos diferentes métodos: cuando se produce una excepción o cuando se produce un salto, la señal \textit{exception\_x} selecciona el valor adecuado para cada caso. La señal \textit{branch\_target\_x} es el resultado de la suma de \textit{pc\_d} y de \textit{branch\_offset\_d} (para esta suma no se utiliza el bloque sumador). El valor de \textit{branch\_offset} es seleccionado por la señal \textit{select\_call\_immediate} entre las señales \textit{call\_immediate} (para instrucciones de llamado a función) y \textit{branch\_immediate}; está última tiene como valor \textit{{{16{inst[15]}}, inst[15:0]}}, lo que es una extensión de signo de la constante de 16 bits almacenado en la memoria de programa.

En la figura \ref{branch_condition} se muestra el camino de datos equivalente a las instrucciones relacionadas con condicionales; 
  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/branch_condition.pdf} \end{center}
    \caption{Camino de datos de los saltos condicionales}\label{branch_condition}
  \end{figure}
  
En la figura \ref{loop_example} se iilustran 3 ciclos que utilizan condicionales; en color azul se muestra el código en C y en negro se muestra el código implementado por el compilador. 
  
  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/loop_example.pdf} \end{center}
    \caption{Ejemplo de código: saltos condicionales}\label{loop_example}
  \end{figure}


\subsubsection{Llamado a función y salto incondicional}
Existen dos tipos de llamado a función y de salto incondicional; su diferencia radica en la forma de almacenar la dirección a la que deben saltar. En la figura \ref{branch_call} se muestra el camino de datos correspondiente a las instrucciones \textit{calli} y \textit{bi}, estas almacenan en la instrucción la dirección y en la figura \ref{branch_call} se muestra el camino de dato correspondiente a las instrucciones \textit{call} y \textit{b} las que almacenan la dirección en un registro.


Para ambos casos el contador de programa es modificado si se activan las señales \textit{condition\_met\_x}, \textit{branch\_m} y \textit{valid\_m}; la señal \textit{valid\_m} se activa cuando se presenta una instrucción válida; \textit{branch\_m} (color amarillo en los graficos) se activa cuando la instrucción que se está ejecutando es un salto o un llamado a función; y  \textit{condition\_met\_x} se activa cuando se cumple con la condición para el salto, debido a que estos saltos y llamados son incondiconales, el MICO32 contempla dos casos en los que activa esta señal, tal como se muestra a continuación (tomado de \textit{rtl/lm32/lm32\_cpu.v}):

\lstset{language=verilog}
\begin{lstlisting}
always @*

begin

    case (instruction[28:26])

    3'b000:  condition_met_x = `TRUE;

    3'b110   condition_met_x = `TRUE;

    ....
    ....
    ....
    default:              condition_met_x = 1'bx;

    endcase 

end
\end{lstlisting}

Los bits \textit{instruction[28:26]} hacen parte del código de la instrucción; el valor para las instrucciones \textit{bi} y \textit{b} es \textit{000} y para \textit{call} y \textit{calli} es \textit{110}, lo que activa \textit{condition\_met\_x} cada vez que se presentan estas instrucciones.

De forma similar a las instrucciones relacionadas con saltos condicionales el valor del contador de programa es igual al valor de las señal \textit{branch\_target\_x} (señal de color verde en las figuras); el valor de esta señal para las instrucciones \textit{call} y \textit{b} proviene del valor almacenado en el registro seleccionado por \textit{instruction\_d [25:21]}. Para las instrucciones \textit{calli} y \textit{bi} el valor está dado por la señal \textit{branch\_offset} la que toma como valor \textit{{{6{ins[25]}},ins[25:0]}} o \textit{{{16{ins[15]}},ins[15:0]}} para una instrucción \textit{call} o  \textit{b} respectivamente.

Adicionalmente, para las instrucciones de llamado a función \textit{call} y \textit{calli} se debe almacenar en el registro \textit{R29} la dirección de memoria siguiente a la que se realizó el llamado a la función, esto con el fín de retornar al flujo de programa principal, esto se logra haciendo uso del pipeline y se utiliza el valor del contador de programa \textit{pc\_m} cuyo valor contiene el valor adecuado para el retorno del llamado a función; el valor de \textit{pc\_m} (señal color morado en las figuras) es asignado a la señal \textit{w\_result} del banco de registros para ser almacenado en el registro indicado por \textit{write\_idx} (señal marrón en los gráficos); la que toma el valor de \textit{29} cuando se presenta una instrucción \textit{calli} o \textit{call}.

  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/branch_call_immediate.pdf} \end{center}
    \caption{Camino de datos de los saltos y llamado a funciones inmediatos}\label{branch_call_immediate}
  \end{figure}

  
  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/branch_call.pdf} \end{center}
    \caption{Camino de datos de los saltos  y llamado a funciones}\label{branch_call}
  \end{figure}



En la figura \ref{call_function} se muestra un ejemplo de uso de la función call. El código en C utilizado para este ejemplo se muestra en color azul. La línea de código \textit{result1 = function(0x30)} hace el llamado a la función \textit{function} pasándole el parámetro \textit{0x30 (decimal 48)}; el código implementado por el compilador se muestra junto al código en C; como se mencionó anteriormente, los primeros registros del banco de registros se usan para pasar parámetros entre funciones, en el paso 1, se almacena el valor \textit{0x30 (48 decimal)} en \textit{r1}; en el paso dos se hace un llamado inmediato a función a la dirección de memoria \textit{0x8C}, lo que hace que el valor del contador de programa tome el valor \textit{0x8C} y se almacene el valor \textit{0x310} en el registro  \textit{ra}.

La función \textit{function} está declarada como \textit{int function(int x)} y reside en la posición de memoria \textit{0x8C}. En el paso 3, se almacena el valor de los registros que se utilizan en la función con el fín de restaurarlos antes de retornar al programa donde fué llamada, esto se hace debido a que solo existe un banco de registros en el procesador y si no se hace esto el valor de los registros antes y después del llamado será diferente lo que ocasionará errores en los algoritmos implementados. EL registro \textit{ra} almacena el valor de la dirección de retorno, y se almacena para asegurar que cuando se hagan llamados a función anidados se retorne a la dirección adecuada. En el paso 4 se restaura el valor de los registros, garantizando la continuidad del programa principal; finalmente, en el paso 6 la función  \textit{ret} carga el valor del \textit{ra} en el contador de programa

  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/call_function.pdf} \end{center}
    \caption{Ejemplo de código: llamado a función}\label{call_function}
  \end{figure}


En la figura \ref{call_function_nested} se ilustra la importancia del almacenamiento de los registros en los llamados a funciones, para este ejemplo se consideró el registro \textit{ra}; cuando se almacena el registro \textit{ra} en la función \textit{F2} para ser restaurado al finalizar la función el flujo de programa retorna a la función \textit{F1}, lo que se ejecuta correctamente en los dos casos. Cuando finaliza \textit{F1} el valor de \textit{ra} varía; cuando no se almacena el valor la dirección de retorno de F1 es modificada por lo que cuando se retorna el contador de programa se hace igual a la dirección de retorno de \textit{F2}.

  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/call_function_nested.pdf} \end{center}
    \caption{Llamado a función anidado}\label{call_function_nested}
  \end{figure}

  
\subsection{Comunicación con la memoria de datos}

Antes de estudiar el camino de datos correspondiente a este grupo de ibstrucciones, hablaremos de los tipos de datos que soporta el procesador MICO32. En la figura \ref{data_types} se muestran ejemplos de manipulación de diferentes tipos de datos y como estos son tratados en la memoria del procesador.

\subsubsection{Tipos de datos}

El primer tipo de datos que se muestra en esta figura es el \textit{char}, la variable \textit{data8} es declarada como un \textit{volatile unsigned char *}, es decir un puntero a un \textit{char} sin signo tipo \textit{volatile}; los tipos de datos \textit{volatile} le indican al compilador que no realice optimizaciones sobre esta variable, lo que es importante cuando se direccionan periféricos. Al puntero \textit{data8} se le asigna la dirección \textit{0x400} y el valor \textit{0x44}. Si se aumenta el valor de la dirección del puntero en una posición \textit{data8++} la nueva dirección será \textit{0x401} y si se aumenta de nuevi pasará a ser \textit{0x402}; lo que indica que el procesador a pesar de ser de 32 bits puede realizar direccionamiento con granularidad byte; esto es muy conveniente para un almacenamiento eficiente de información, de no ser así se utilizaría una palabra de 32 bits para almacenar 8 bits.

La segunda parte de la figura \ref{data_types} ilustra el manejo del tipo de dato \textit{short} el cual es de 8 bits; para esto se utiliza en puntero \textit{data16} con una dirección inicial de \textit{0x200} y un valor de \textit{0x2020}; al aumentar la dirección del puntero en 1 (data16++) la dirección resultante es  \textit{0x202}, lo que permite el almacenamiento eficiente de este tipo de dato.

Finalmente se ilustra el tipo de datos \textit{int} y se observa como las direcciones de memoria inical y final después de aumentar el valor del puntero son \textit{0x300} \textit{0x304}; lo que muestra que el direccionamiento interno de la memoria depende del tipo de datos.


  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/data_types.pdf} \end{center}
    \caption{Tipos de datos soportados por el procesador Mico32}\label{data_types}
  \end{figure}


El procesador MICO32 posee 4 señales \textit{D\_SEL\_O[3:0]} que son utilizadas para indicarle a los periféricos el tipo de operación de lectura/escritura que se está efectuando; en la figura \ref{type_char} se observa que estas señales se activan de forma individual indicando el byte que se está direccionando; en la figura \ref{type_short} las señales se activan por parejas indicando el grupo de 2 bytes que se está direccionando; finalmente en la figura \ref{type_int} las 4 señales se activan al tiempo lo que indica un acceso a los 4 bytes al mismo tiempo.

  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/char.pdf} \end{center}
    \caption{Acceso a un data tipo \textit{char}}\label{type_char}
  \end{figure}
 
  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/short.pdf} \end{center}
    \caption{Acceso a un data tipo \textit{short}}\label{type_short}
  \end{figure}

    \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/int.pdf} \end{center}
    \caption{Acceso a un data tipo \textit{int}}\label{type_int}
  \end{figure}
  
  
\subsubsection{Escritura a la memoria de datos}
El acceso a memoria de datos permite extender las capacidades del procesador posibilitando la conexión de periféricos; los que a su vez, realizan la comunicación con el exterior utilizando diferentes protocolos de comunicación y medios físicos. En esta subsección se describirá la forma en la que el MICO32 implementa las operaciones de lectura y escritura a la memoria de datos.

En la figura \ref{data_write} se ilustra el camino de datos asociado a las instrucciones \textit{sb}, \textit{sh} y \textit{sw}. En las tres, el valor contenido en el registro direccionado por \textit{instruction\_d[25:21]} (RX señales color rojo en la figura) más el valor de 16 bits (con signo extendido a 32 bits) forman la dirección a la que se desea escribir. El valor contenido en el registro direccionado por \textit{instruction\_d[20:16]} (RY señales color azul en la figura) corresponde al dato que será escrito en esa posición de memoria; de esta forma se construyen los buses de datos y direcciones del procesador. Cómo se dijo anteriormente el MICO32 direcciona con granularidad de byte, por esta razón en las instrucciones \textit{sh} y \textit{sw} se indica el valor escrito en las direcciones \textit{+1} y \textit{+1, +2 y +3} respectivamente; indicando el tamaño en bytes del tipo de dato escrito. Estas señales ingresan a un módulo llamado \textit{load\_store\_unit} que se encarga de generar las señales 
correspondientes al bus \textit{wishbone}, más adelante estudiaremos en detalle el funcionamiento de este bus.


En la figura \ref{type_char},  y \ref{type_int} se muestran las formas de onda cuando se escribe un dato tipo char (\textit{0x44}) a la dirección \textit{0x400}, el dato escrito en el bus es \textit{0x44444444} para que el periférico pueda utilizar cualquiera de las cuatro partes del bus de datos \textit{D\_DAT\_O[7:0]}, \textit{D\_DAT\_O[15:8]}, \textit{D\_DAT\_O[23:16]}, \textit{D\_DAT\_O[31:24]}, algo similar ocurre en la escritura del tipo de dato \textit{short} (con valor \textit{0x2020}) mostrado en la figura  \ref{type_short}, aquí se repite el dato para poder utilizar dos partes del bus del datos \textit{D\_DAT\_O[15:0]} y \textit{D\_DAT\_O[31:16]}.


  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/store.pdf} \end{center}
    \caption{Camino de datos de las instrucciones de escritura a memoria}\label{data_write}
  \end{figure}

  

  
  \subsubsection{Lectura}
En la figura \ref{data_read} se muestra el camino de datos asociado a las instrucciones \textit{lb/lbu}, \textit{lh/lhu} y \textit{lw}. La dirección de la cual se leera se calcula de forma similar al caso de la escritura; el valor contenido en el registro direccionado por \textit{instruction\_d[25:21]} (RY señales color rojo en la figura). El dato leído por el módulo \textit{load\_store\_unit} (señal morada en la figura) es almacenado en el registro cuya dirección está dada por \textit{instruction\_d[20:16]}.

  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/load.pdf} \end{center}
    \caption{Camino de datos de las instrucciones de escritura a memoria}\label{data_read}
  \end{figure}

\subsection{Interrupciones}

%   \begin{figure}
%     \begin{center} \includegraphics[scale=.2]{./LM32/images/exception.pdf} \end{center}
%     \caption{Camino de datos correspondiente a las excepciones}\label{exception}
%   \end{figure}

Existen dos formas de conocer si un periférico conectado al procesador requiere atención por parte del procesador; examinando de forma constante los registros de estado del periférico o utilizando interrupciones. La consulta constante de los registros de estado del periférico requiere incluir en el código una rutina que realice esta operación, la cual debe ser llamada de forma regular en el programa principal, la velocidad con que se realice esta consulta debe ser la adecuada para que no se pierdan eventos; debido a esto; uno de los problemas de esta técnica es que al aumentar el número de periféricos aumenta el tiempo entre consultas para un periférico, lo que aumenta la posibilidad de pérdida de eventos; adicionalmente, aumenta el tiempo dedicado a la consulta, lo que disminuye el tiempo disponible para ejecutar las tareas software en el procesador.

Las interrupciones modifican el flujo normal de ejecución del sistema y son originadas por señales dedicadas, lo que hace que su atención ocurra de forma inmediata. Cuando se presenta una interrupción, el valor del contador de programa toma un valor fijo que recibe el nombre de vector de interrupción, el valor del vector de interrupción está formado por (ver figura \ref{exception_generation} señales de color rojo) una dirección base \textit{EBA} (Exception Base Address) que por defecto es \textit{0x00}, un índice que indica la exepción que se presentó \textit{eid\_x} (6 para la interrupción) y tres ceros; estos tres ceros hacen que el espacio entre vectores de excepción sea de 8 palabras de 32 bits, por lo que la rutina de atención a la interrupción debe tener máximo 8 instrucciones (esta rutina se explicará más adelante); para la interrupción el valor del vector es de \textit{0x30}. 

Como se puede observar en la figura \ref{exception_generation} para que se genere una excepción (señales de color azul), se debe activar cualquiera de las señales \textit{instruction\_bus\_error\_exception}, \textit{sysrem\_call\_exception\_exception}, \textit{data\_bus\_error\_exception}, \textit{divide\_by\_zero\_exception} o \textit{interrupt\_exception}; lo que activará la señal \textit{branch\_taken\_m} quien a su vez realiza el cambio en el contador de programa \textit{pc\_a}. Para que la señal \textit{interrupt\_exception} se active es necesario: 1- habilitar la generación de interrupciones, es decir, que el flag \textit{ie} (interrupt enable) está activo; 2- habilitar la generación de la interrupción deseada, para esto el bit correspondiente a la interrupción debe ser igual a 1 en la señal \textit{im} (interrupt mask), lo que recibe el nombre de \textit{enmascaramiento} y 3 - Que el periférico asociado a la interrupción realice una solicitud de atención activando su señal de interrupción, lo que 
origina una activación de la señal correspondiente en \textit{ip} (interrupt pending). 

Al activarsre la señal \textit{exception\_x} la variable que direcciona el registro a ser escrito en el banco de registros \textit{write\_idx} toma el valor \textit{30 decimal} (\textit{ea} - exception address) y el valor a ser escrito (\textit{w\_result}) será \textit{{pc\_m, 2'b00}} (los saltos en el contador de programa es de a 4 bytes, debido a que las instrucciones son de 32 bits, por esta razón los dos bits menos significativos no son tomados en cuenta); lo que garantiza que al salir de la interrupción, el programa principal continuará donde se interrumpió.


  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/exception_generation.pdf} \end{center}
    \caption{Camino de datos correspondiente a las generación de excepciones}\label{exception_generation}
  \end{figure}  

 

 \subsubsection{Rutina de atención a la interrupción}
 A continuación se lista la rutina que se ejecuta cada vez que se presenta una interrupción; como se dijo anteriormente, la dirección del vector de interrupción debe ser \textit{0x48}, por lo que este código debe residir en la memoria de programa en dicha dirección.
 
 
 \lstset{language=C, numbers=left, firstnumber=48}
\begin{lstlisting}
	sw      (sp+0), ra
	calli   _save_all
	rcsr	r1, IP 
	calli   irq_handler
	mvhi    r1, 0xffff
	ori     r1, r1, 0xffff
	wcsr	IP, r1 
	bi      _restore_all_and_eret
\end{lstlisting}

En la línea \textit{48} se almacena el valor del registro \textit{ra} en la pila (la pila es una región de la memoria RAM que se utiliza para diferentes propósitos en la ejecución de un programa), esto se hace para que al salir de la rutina de atención a la interrupción el programa continúe de forma adecuada, de no hacer esto, si la interrupción se produjo cuando se estaba ejecutando una función el valor de retorno de la interrupción se modificaría. 

En la línea \textit{49} se hace un llamado a la función \textit{save\_all}:

 \lstset{language=C, numbers=none}
\begin{lstlisting}
	addi    sp, sp, -128
	sw      (sp+4), r1
	...
	sw      (sp+108), r27
#endif
	sw      (sp+120), ea
	sw      (sp+124), ba
	/* ra and sp need special handling, as they have been modified */
	lw      r1, (sp+128)
	sw      (sp+116), r1
	mv      r1, sp
	addi    r1, r1, 128
	sw      (sp+112), r1        
	ret
\end{lstlisting}

En esta función, toma una ``fotografía'' del estado del procesador en el instante en que se presenta la interrupción,  almacenando el valor de todos los registros en la pila, esto se hace para garantizar que el estado del procesador antes y después de la interrupción sea el mismo. 

En la línea \textit{49} se almacena el valor de la señal \textit{ip} (interrupt pending) en el registro \textit{r1}, esto se hace para pasar parámetros a la función que será llamada en la línea \textit{50}. \textit{irq\_handler} es la función que realizará las acciones correspondientes a una determinada interrupción, esta función debe ser declarada en C en cualquier archivo que haga parte del código fuente de la aplicación (en los ejemplos del repositorio se declara en el archivo \textit{soc-hw.c}) como: \textit{void irq\_handler(uint32\_t pending)}.

En las líneas \textit{51} - \textit{53} se llena con unos la señal \textit{IP}, lo que equivale a una restauración de esta señal, y puede verse como una forma de informarle al procesador que las interrupciones ya fueron atendidas. Finalmente en la línea \textit{54} se hace un llamado a la función \textit{\_restore\_all\_and\_eret}:

\lstset{language=C, numbers=none}
\begin{lstlisting}
        lw      r1, (sp+4)
        ...
        lw      r27, (sp+108)
        lw      ra, (sp+116)
        lw      ea, (sp+120)
        lw      ba, (sp+124)
        /* Stack pointer must be restored last, in case it has been updated */
        lw      sp, (sp+112)
        eret
\end{lstlisting}

Esta función: restaura el valor de todos los registros del procesador, incluyendo los registros \textit{ra, ea y ba}, el registro \textit{ea} se almacena para asegurar el correcto funcionamiento ante el caso de excepciones anidades; y ejecuta la instrucción \textit{eret} la que hace que el contador de programa tome el valor almacenado en el registro \textit{ea} con lo que el programa retorna a la siguiente instrucción del punto donde se generó la interrupción.


Como se mencionó anteriormente, para que la interrupción se presente es necesario habilitar las interrupciones globales y la máscara asociada al periférico. Para esto, el archivo \textit{crt0ram.S} suministra las siguientes funciones:


\lstset{language=C, numbers=none}
\begin{lstlisting}
irq_enable:
	mvi     r1, 1
	wcsr	IE, r1
	ret

irq_disable:
	mvi     r1, 0
	wcsr	IE, r1
	ret

irq_set_mask:
	wcsr	IM, r1
	ret	
\end{lstlisting}

En este código se utiliza la instrucción \textit{wcsr} y en la función de atención a la interrupción ya se había utilizado la instrucción \textit{rcsr} (\textit{rcsr	r1, IP}); estas instrucciones realizan operaciones de escritura y lectura sobre los registros de estatus y control del procesador. En la figura \ref{exception_csr} se muestra el camino de datos relacionado con estas intrucciones.

\begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/exception_csr.pdf} \end{center}
    \caption{Camino de datos correspondiente al acceso de los registros asociados a las excepciones}\label{exception_csr}
  \end{figure}
  
El camino de color rojo muestra la escritura utilizando la instrucción \textit{wcsr}; \textit{instruction\_d[20:16]} contiene la dirección del registro a ser escrito en \textit{csr}; y \textit{instruction\_d[25:21]} el registro de estatus y control a escribir. 

La lectura de los registros de estado y control se muestra en color morado en la figura; de forma similar a la escritura \textit{instruction\_d[25:21]} direcciona el registro a leer y \textit{instruction\_d[15:11]} la dirección del registro que almacenará el valor leído.

\subsection{Retorno de función y de excepción}

La figura \ref{eret_ret} muestra el camino de datos asociado a las instrucciones de retorno de excepción y de función \textit{eret} y \textit{ret}; en estas instrucciones, el valor de la dirección del registro que va a ser almacenado en el contador de programa es fijo (\textit{instruction\_d[25:21]}), siendo \textit{30} para la instrucción \textit{eret} y \textit{29} para la instrucción \textit{ret}. El valor contenido en estos registros pasa a la señal \textit{branch\_target} y su valor será almacenado en el contador de programa retornando a la dirección siguiente a la que se produjo la excepción o el llamado a función. 

  \begin{figure}
    \begin{center} \includegraphics[scale=.2]{./LM32/images/eret_ret.pdf} \end{center}
    \caption{Camino de datos asociado al retorno de función y de excepción}\label{eret_ret}
  \end{figure}

  
  
  
En la Figura \ref{interrupt_flow} se resume el proceso de atención a la interrupción. La solicitud de atención por parte de un periférico recibe el nombre de \textbf{IRQ} (interrupt request) y la rutina que atiende esta solicitud recibe el nombre de \textit{ISR} (interrupt service routine)

  \begin{figure}
    \begin{center} \includegraphics[scale=.5]{./LM32/images/interrupt_process.pdf} \end{center}
    \caption{Flujo asociado a la atención de una interrupción}\label{interrupt_flow}
  \end{figure}









%********************************************************************************************************************
%********************************************************                              SECCIÓN   ARQUITECTURA SoC
%********************************************************************************************************************

\section{Arquitectura del SoC LM32}
En la sección anterior se explicó el funcionamiento detallado de cada grupo de instrucciones del procesador MICO32; en esta sección se realizará una descripción de un SoC (sistema sobre silicio) basado en el procesador MICO32; esta arquitectura permitirá entender los SoC modernos desde el punto de vista estructural y de programación

  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/LM32_SoC_block_diagram.pdf} \end{center}
    \caption{Diagrama de bloques del SoC LM32}\label{SoC_block_diagram}
  \end{figure}


En la figura \ref{SoC_block_diagram} se muestra el diagrama de bloques del SoC \textit{LM32}, el cual tiene como unidad de procesamiento central el procesador MICO32; esta CPU se conecta a una serie de periféricos a través de el bus \textit{wishbone}. Ka funcionalidad del SoC está determinada por los periféricos implementados, en esta sección se realizará una descripción de cuatro periféricos básicos para el desarrollo de operaciones básicas de entrada/salida:

\begin{itemize}
 \item Boot-RAM: Esta memoria almacena la aplicación que se ejecutará al inicializar el SoC.
 \item UART (Universal Asynchronous Receiver-Transmitter): Puerto serie que permite comunicarse con el exterior y es utilizado como medio de depuración. 
 \item TIMER: Encargado de generar bases de tiempo precisas, de vital importancia en el funcionamiento de la mayoría de las aplicaciones.
 \item GPIO: Pines de entrada/salida de propósito general.
\end{itemize}

Adicionalmente, existe un módulo llamado \textit{conbus} que realiza la interconexión entre los periféricos y el procesador, su arquitectura y funcionamiento se explicarán más adelante.


\subsection{Bus wishbone}
El bus \textit{wishbone} es un bus diseñado para comunicar los diferentes comonentes de un SoC, este bus es abierto y puede ser utilizado libremente. A continueación se listan las señales que componen este bus:

\begin{itemize}
 \item \textit{ack\_o}: La activación de esta señal indica la terminación normal de un ciclo del bus. 
 \item \textit{addr\_i}: Bus de direcciones. 
 \item \textit{cyc\_i}: Esta señal se activa cuando un ciclo de bus válido se encuentra en progreso.
 \item \textit{sel\_i}: Estas señales indican cuando se coloca un dato válido en el bus \textit{dat\_i} durante un ciclo de escritura, y cuando deberían estar presentes en el bus \textit{dat\_o} durante un ciclo de lectura. El número de señales depende de la granularidad del puerto. El LM32 maneja una granularidad de 8 bits sobre un bus de 32 bits, por lo tanto existen 4 señales para seleccionar el byte deseado (\textit{sel\_i(3:0)}). 
 \item \textit{stb\_i}: Esta señal se activa cuando se selecciona un esclavo; el cual debe responder a las otras señales únicamente cuando se activa esta señal. El esclavo debe activar la señal \textit{ack\_o} como respuesta a la activación de \textit{stb\_i}.
 \item \textit{we\_i}: Esta señal indica la dirección del flujo de datos; en un ciclo de lectura tiene un nivel lógico bajo y en escritura tiene un nivel lógico alto. 
 \item \textit{dat\_i}: Bus de datos de entrada.
 \item \textit{dat\_o}: Bus de datos de salida.
\end{itemize}

En la figura \ref{uart_read_waves} se muestra un ciclo de lectura típico a un periférico con dirección de memoria \textit{0xF0000000}, en ella podemos observar la activación de las señales \textit{wb\_cyc\_i} y \textit{wb\_stb\_i} indicando un ciclo de bus válido y la selección del esclavo, el valor de \textit{wb\_we\_i} indica que el acceso es de lectura, a lo que el esclavo debe responder colocando el dato requerido por el procesador en el bus de salida \textit{wb\_dat\_o} y con la activación de la señal \textit{wb\_ack\_o}

  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/uart_read_waves.pdf} \end{center}
    \caption{Ciclo de lectura del bus wishbone}\label{uart_read_waves}
  \end{figure}

En la figura \ref{uart_block_write} se muestra la escritura del valor \textit{0x2A} a la dirección de memoria \textit{0xF0000004}, las formas de onda son similares a las del ciclo de lectura, salvo que el valor de la señal \textit{wb\_we\_i} es uno indicando la escritura.

  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/uart_read_waves.pdf} \end{center}
    \caption{Ciclo de escritura del bus wishbone}\label{uart_write_waves}
  \end{figure}


\subsubsection{Interface del bus wishbone (conmax)}

El bus wishbone tiene una arquitectura maestro/esclavo en la que solo los maestros pueden iniciar las operaciones de lectura y escritura y únicamente el esclavo al que se le hace el requerimiento debe responder. Para coordinar la comunicación entre múltiples maestros se debe incluir un árbitro, que en el LM32 recibe el nombre de \textit{conmax}. La figura \ref{conbus} muestra el diagrama de bloques de este árbitro.

  \begin{figure}
    \begin{center} \includegraphics[scale=.35]{./LM32/images/conbus.pdf} \end{center}
    \caption{Circuito de interconexión del bus wishbone}\label{conbus}
  \end{figure}
  
  
Una de las funciones del árbitro \textit{conmax} es fijarle un rango de direcciones único a cada periférico, por esta razón todo árbitro debe tener un decodificador de direcciones (módulo \textit{ADDRESS DECODER} en la figura \ref{conbus}) que tiene como entradas los bits más significativos del bus de direcciones, en este caso solo se usan dos bits (mx\_adr\_i[29:28]) ya que solo se cuenta con cuatro periféricos; este decodificador activa las señales \textit{slave\_sel[3:0]} de acuerdo a la definición en el archivo \textit{system.v}:

\lstset{language=verilog}
\begin{lstlisting}
 conbus #(
  .s_addr_w(2),
  .s0_addr(2'b00),	// bram     0x00000000 
  .s1_addr(2'b01),	// uart     0x20000000 
  .s2_addr(2'b11),	// timer    0x60000000 
  .s3_addr(2'b10)	// gpio     0x40000000 
 ) conbus0(
\end{lstlisting}

Asignado las direcciones de memoria \textit{0x00000000 - 0x1FFFFFFF}, \textit{0x20000000 - 0x3FFFFFFF}, \textit{0x60000000 - 0x7FFFFFFF} y \textit{0x40000000 - 0x5FFFFFFF} a la BRAM, UART, TIMER y GPIO respectivamente, la activación de \textit{slave\_sel[3:0]} hace que se active su correspondiente señal \textit{s0\_stb\_[3:0]} ( y se presenta un ciclo válido de bus ) indicándole al periférico que ha sido seleccionado para una operación de lectura o escritura.


En la figura \ref{conbus_write} se muestra el circuito simplificado del árbitro \textit{conmax} para una operación de escritura; en ella se puede observar que todos los esclavos comparten las señales \textit{s0\_adr\_o, s0\_cti\_o, s0\_sel\_i, s0\_dat\_o, s0\_we\_o, s0\_cyc\_o y sx\_dat\_i}, las cuales son la salida de un multiplexor que selecciona entre las señales correspondientes a los diferentes maestros del SoC (m0 y m1 en este caso); las señales \textit{gnt[0] y gnt[1]} seleccionan al maestro que se conectará con todos los esclavos, por esta razón nunca se activarán las dos al tiempo. Las únicas señales que no comparten los esclavos wishbone son las que indican a los periféricos que han sido seleccionados para una transferencia de información \textit{s0\_stb\_[3:0]}.  \textit{slave\_sel\_[3:0]} 

  \begin{figure}
    \begin{center} \includegraphics[scale=.35]{./LM32/images/conbus_write.pdf} \end{center}
    \caption{Circuito equivalente a una operación de escritura para el árbitro del bus wishbone}\label{conbus_write}
  \end{figure}

En la figura \ref{conbus_read} se muestra el circuito simplificado del árbitro \textit{conmax} para una operación de lectura; en ella podemos observar que los buses de datos de los periféricos \textit{s[3:0]\_dat\_i} se conectan a los buses de datos de los maestros \textit{m[1:0]\_dat\_o}; las señales \textit{slave\_sel\_[3:0]} se activan una a la vez y seleccionan el esclavo que se conectará con el maestro.

 \begin{figure}
    \begin{center} \includegraphics[scale=.35]{./LM32/images/conbus_read.pdf} \end{center}
    \caption{Circuito equivalente a una operación de lectura para el árbitro del bus wishbone}\label{conbus_read}
  \end{figure}

Para ilustrar de forma gráfica la operación del árbitro se implementó un programa que escribe los siguientes valores a las direcciones de los periféricos UART, TIMER y GPIO:

\begin{enumerate}
 \item \textit{0xAA} a la dirección  del esclavo 1 \textit{0x20000004}
 \item \textit{0x55} a la dirección  del esclavo 3 \textit{0x40000000}
 \item \textit{0xFF} a la dirección  del esclavo 2 \textit{0x60000000}
\end{enumerate}

Como podemos ver en la figura \ref{conbus_waves}, las señales \textit{gnt[0]} y \textit{gnt[1]} se activan de forma alterna y solo esta activa una de ellas, cuando se escribe el valor \textit{0xAA} a la dirección \textit{0x20000004} se activan las señales  \textit{slave\_sel\_[1]} y \textit{s1\_stb\_o} indicando la activacíón del primer periférico; similarmente, cuando se escribe el valor \textit{0x55} a la dirección \textit{0x40000000} se activan las señales  \textit{slave\_sel\_[3]} y \textit{s3\_stb\_o} indicando la activacíón del tercer periférico y finalmente, cuando se escribe el valor \textit{0xFF} a la dirección \textit{0x60000000} se activan las señales  \textit{slave\_sel\_[2]} y \textit{s2\_stb\_o} indicando la activacíón del segundo periférico.
  
 \begin{figure}
    \begin{center} \includegraphics[scale=.35]{./LM32/images/conbus_signals.pdf} \end{center}
    \caption{Formas de onda del proceso de comunicación entre la CPU y los periféricos usando el bus wishbone}\label{conbus_waves}
 \end{figure}


 
 
\subsection{Arquitectura de los periféricos}
En esta subsección se realizará un estudio de la arquitectura de los esclavos wishbone, se analizarán tres periféricos: GPIO, UART y TIMER

\subsubsection{Periférico GPIO}
En todo SoC es necesario contar con pines de entrada/salida de propósito general, este sencillo periférico permite controlar la dirección de un pin, controlar el valor de un pin de salida y leer el valor de un pin de entrada; en la figura \ref{gpio_full} se muestra el diagrama de bloques de este periférico.

  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/gpio.pdf} \end{center}
    \caption{Ejemplo de periférico wishbone: GPIO}\label{gpio_full}
  \end{figure}

La dirección del pin es fijada con un buffer tri-estado que a su vez es controlado por el valor almacenado en el registro \textit{gpio\_dir} los registros \textit{gpio\_o} y \textit{gpio\_input} almacenan los valores escritos y leidos de los pines respectivamente.

Para entender el comportamiento de este periférico analizaremos los circuitos de lectura y escritura de forma separada. En la figura \ref{gpio_read} se muestra el circuito de lectura; el valor del registro \textit{gpio\_input} es almacenado en un registro que está conectado al bus de datos de salida del periférico \textit{wb\_dat\_o} cuando la señal \textit{wb\_rd} sea igual a 1 y la señal \textit{ack} sea igual a cero. \textit{wb\_rd} es igual a 1 cuando se presente un ciclo de bus válido, se seleccione el periférico y se realice una operación de lectura.

  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/gpio_read.pdf} \end{center}
    \caption{Circuito equivalente de lectura del periférico GPIO}\label{gpio_read}
  \end{figure}

El circuito simplificado de escritura se muestra en la figura \ref{gpio_write}; en este periférico el bus de datos proveniente del maestro puede almacenarse en los registros \textit{gpio\_dir} y \textit{gpio\_o}; el multiplexor controlado por \textit{wb\_adr\_i[3:2]} selecciona donde será almacenado el dato. La transferencia al registro seleccionado se realiza únicamente cuando la señal \textit{wb\_wr} sea igual a 1 y la señal \textit{ack} sea igual a cero. \textit{wb\_wr} es igual a 1 cuando se presente un ciclo de bus válido, se seleccione el periférico y se realice una operación de escritura.


    \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/gpio_write.pdf} \end{center}
    \caption{Circuito equivalente de escritura del periférico GPIO}\label{gpio_write}
  \end{figure}

Tanto en la operación de lectura como en la de escritura se debe generar la señal \textit{wb\_ack\_o} para indicarle al maestro que la solicitud de comunicación ha sido recibida y atendida; para esto se implementó el circuito compuesto de las 2 compuertas AND, una compuerta OR y un FLIP FLOP, este circuito hace que la señal \textit{ack} sea igual a 1 cuando cualquiera de las señales \textit{wb\_rd} o \textit{wb\_wr} sea igual a 1 y el estado de la señal \textit{ack} sea igual a 0; es decir, cuando el dispositivo pasa del estado no seleccionado a ser seleccionado para una operación de lectura o escritura.



\subsubsection{Periférico UART}

En la figura \ref{uart_block_full} se muestra el diagrama de bloques de un periférico un poco más complejo una UART, su arquitectura se basa en un módulo que implementa las tareas de comunicación que se encuentra descrito en el archivo \textit{uart.v}; en el archivo \textit{wb\_uart.v} se hace la adaptación de esta unidad funcional al bus wishbone, esta arquitectura permite que el módulo funcional pueda ser conectado a diferentes buses sin tener que re-escribir todo el código.

  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/uart_block_full.pdf} \end{center}
    \caption{Ejemplo de periférico wishbone: UART}\label{uart_block_full}
  \end{figure}


Del diagrama de bloques de la UART podemos observar que su arquitectura es similar a la del GPIO, existen los mismos bloques de interconexión con los buses de datos de entrada y de salida y se utiliza el mismo circuito para generar la señal \textit{ack}.

El circuito simplificado de salida se muestra en la figura \ref{uart_block_read}, se observa que existen dos valores que pueden ser leídos desde el procesador: la señal \textit{rx\_data} y los bits de estado \textit{tx\_}, \textit{tx\_error} y \textit{tx\_avail}; en este caso la línea de dirección \textit{wb\_adr\_i[2]} selecciona la información que será transmitida al procesador.


  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/uart_block_read.pdf} \end{center}
    \caption{Circuito equivalente de lectura de la UART}\label{uart_block_read}
  \end{figure}

  \textit{wb\_adr\_i[3:2]}

El circuito de escritura se muestra en la figura \ref{uart_block_write}, en este ejemplo el bus de datos proveniente del maestro se conecta directamente a la señal \textit{tx\_data} ya que este periférico no permite modificar otros parámetros. Por esta razón el circuito solo transmite un 1 a la señal \textit{uart\_txd} lo que hace que la uart transmita el valor fijado por la señal \textit{tx\_data}.

    \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/uart_block_write.pdf} \end{center}
    \caption{Circuito equivalente de escritura de la UART}\label{uart_block_write}
  \end{figure}

  
\subsubsection{Periférico TIMER}
En la figura \ref{timer} se muestra el diagrama de bloques resumido del periférico TIMER; el cual posee 6 registros que pueden ser modificados y leídos por el procesador. De nuevo la arquitectura de este periférico es similar a los anteriores así como el circuito de generación de la señal \textit{ack}

  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/timer.pdf} \end{center}
    \caption{Ejemplo de periférico wishbone: TIMER}\label{timer}
  \end{figure}

En la figura \ref{timer_read} se muestra el circuito de lectura del periférico timer. La diferecia frente a los anteriores es la posibilidad de leer 6 diferentes variables; por esta razón se utilizan tres señales del bus de direcciones \textit{wb\_adr\_i\_[5:3]}.
  
  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/timer_read.pdf} \end{center}
    \caption{Circuito equivalente de lectura del periférico TIMER}\label{timer_read}
  \end{figure}

En la figura \ref{timer_write} se muestra el diagrama de escritura del timer, de forma similar al circuito de lectura la señal \textit{wb\_adr\_i\_[5:3]} selecciona el registro que almacenará el valor proveniente del procesador.

    \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/timer_write.pdf} \end{center}
    \caption{Circuito equivalente de escritura del periférico TIMER}\label{timer_write}
  \end{figure}

 
\subsection{Interfaz Software}
En la subsección anterior se hizo una descripción de los diferentes componentes de la configiración básica del SoC LM32; aquí, se explicará como controlar desde un programa en C la comunicación con los periféricos. 

\subsubsection{Estructura de datos del periférico}
Para facilitar el acceso a los diferentes registros de un periférico es conveniente declarar un nuevo tipo de dato que haga una representación de su mapa de memoria.

En la figura \ref{gpio_sw_interface} se muestra el diagrama de bloques del GPIO y la declaración del tipo de dato \textit{gpio\_t}; el multiplexor que selecciona el sitio donde se almacenará el dato proveniente del procesador está controlado por las líneas de dirección \textit{wb\_adr\_i[3:2]} cuando estas señales tengan el valor de \textit{01} o lo que es lo mismo la dirección termine en \textit{0x04} se seleccionará el registro \textit{gpio\_o}; si estas señales tengan el valor de \textit{10} o lo que es lo mismo la dirección termine en \textit{0x08} se seleccionará el registro \textit{gpio\_dir}. De aquí la posición de los elementos \textit{write} y \textit{w\_dir} de la estructura \textit{gpio\_t}; al ser declarada la variable \textit{read} como \textit{uint32\_t} se reservan cuatro bytes (0x00, 0x01, 0x02 y 0x03) para almacenar esta variable, la siguiente posición de memoria (0x04) corresponde a la variable \textit{write}, la cual es declarada como un tipo de dato \textit{uint32\_t} por lo que se 
reservan cuatro bytes para su almacenamiento (0x04, 0x05, 0x06 y 0x07), en la siguiente posición de memoria (0x08) se almacenará la variable \textit{w\_dir} y se reservarán cuatro bytes (0x08, 0x09, 0x0A y 0x0B) para su almacenamiento. 

Como puede observarse en la figura \ref{gpio_sw_interface}, el contenido del registro \textit{gpio\_input} siempre está disponible sin importar el valor de la dirección, lo que indica que el dato estará disponible siempre que se seleccione el periférico para una operación de lectura, en este caso se colocó en la primera posición de memoria por conveniencia.

Todos los tipos de datos declarados en la estructura \textit{gpio\_t} son del tipo \textit{volatile}. este tipo de dato le indica al compilador que no realice optimizaciones sobre esta variable.

  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/gpio_sw_interface.pdf} \end{center}
    \caption{Definición de la dirección de los registros internos del GPIO}\label{gpio_sw_interface}
  \end{figure}

En la figura \ref{uart_sw_interface} se observa la declaración del tipo de dato \textit{uart\_t} y su relaciín con el circuito interno de la UART. Aquí, \textit{wb\_adr\_i[2]} controla el valor que será pasado al bus de datos del maestro; si \textit{wb\_adr\_i[2]} es 0, se transmite el valor del registro \textit{UCR}, si el valor de \textit{wb\_adr\_i[2]} es 1, se transmitirá el valor de la señak \textit{rx\_data}. Al definir la variable \textit{ucr} al comienzo de la estructura y al asignarle el tipo \textit{uint32\_t} se reservan los bytes 0x00, 0x01, 0x02 y 0x03 para su almacenamiento; al declarar a continuación la variable \textit{uint32\_t} \textit{rxtx} se reservan los siguientes cuatro bytes (0x04, 0x05, 0x06 y 0x07) para su almacenamiento.
  
  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/uart_sw_interface.pdf} \end{center}
    \caption{Definición de la dirección de los registros internos de la UART}\label{uart_sw_interface}
  \end{figure}

Finalmente, en la figura \ref{timer_sw_interface} se muestra la declaración del tipo de dato \textit{timer\_t} y su relación con los registros internos del periférico.
  
  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/timer_sw_interface.pdf} \end{center}
    \caption{Definición de la dirección de los registros internos del TIMER}\label{timer_sw_interface}
  \end{figure}


 \subsubsection{Dirección de memoria de los periféricos}
 
Una vez creados los tipos de datos que representan los registros internos de los periféricos se debe asignar un valor a la dirección base de cada uno de ellos, esta dirección debe ser la misma que le asigna el decodificador de direcciones del árbitro wishbone. En la figura \ref{peripheral_soc} se muestra el valor que deben tomar estas direcciones.
 
 
  \begin{figure}
    \begin{center} \includegraphics[scale=.6]{./LM32/images/peripheral_soc.pdf} \end{center}
    \caption{Asignación de la dirección de memoria a los periféricos}\label{peripheral_soc}
  \end{figure}

  
  
  

\subsubsection{}




